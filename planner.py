"""
Program:    Debt Freedom Planner
Assignment: Student Choice Program
Class:      Programming with Functions (CSE 111), BYU-Idaho
Author:     Traek Malan
Updated:    2024-07-25
GitHub:     https://github.com/traek/debt-freedom-planner
"""

from datetime import datetime as dt
import amortization.period as period # used for non-accelerated estimates only

debts = {}
no_change_plans = {}
snowball_plans = {}

debts = {
    'VentureOne VISA':  ['CapitalOne', 4000, 0.0899,  85.00, dt(2029, 5, 24)],
    'Best Buy MC':      ['Citibank',   6500, 0.1599, 165.00, dt(2029, 3, 24)],
    'Costco VISA':      ['Citibank',   1500, 0.1899,  39.00, dt(2029, 7, 24)],
    'Timmy\'s Bill':    ['Dr. Smith',  1000, 0.1,     25.00, dt(2028, 8, 24)],
    'Corolla Loan':     ['Chase',      8500, 0.0525, 200.00, dt(2028, 6, 24)]
}

# Columns in debts dictionary
DEBTOR_INDEX = 0
BALANCE_INDEX = 1
INTEREST_INDEX = 2
PAYMENT_INDEX = 3
ESTIMATED_PAYOFF_INDEX = 4

# Columns in _plans dictionaries
PLAN_DEBT_INDEX = 0
PLAN_MONTH_INDEX = 1
PLAN_PMT_INDEX = 2
PLAN_EXTRA_INDEX = 3
PLAN_PMT_PRINCIPLE_INDEX = 4
PLAN_PMT_INTEREST_INDEX = 5
PLAN_RUNNING_BALANCE_INDEX = 6
PLAN_INTEREST_TO_DATE_INDEX = 7

# place to implement translation(s)
MENU_IMPORT_DEBT = "Import debts from CSV template"
MENU_ADD_DEBT = "Add Debt"
MENU_REMOVE_DEBT = "Remove Debts"
MENU_LIST_DEBT = "List Debts"
MENU_GENERATE_PLAN = "Generate Repayment Plan"
MENU_LIST_PLANS = "View repayment plans"
MENU_EXPORT_PLANS = "Export repayment plans to CSV"
MENU_INSTRUCTIONS = "Toggle Instructions"
MENU_EXIT = "Exit"
MENU_HEADER = "Please select one of the following options"
MENU_PROMPT = "Enter selection"
DISPLAY_DEBT = "Debt Name"
DISPLAY_DEBTOR = "Debtor"
DISPLAY_BALANCE = "Current Balance"
DISPLAY_INTEREST = "Interest Rate"
DISPLAY_PAYMENT = "Minimum Payment"
DISPLAY_ACCELERATION = "Acceleration Amount"
DISPLAY_DEBT_SELECTION = "Debt Plan Type"
INSTRUCTIONS_ADD_DEBT = f"{MENU_ADD_DEBT.upper()}:\n[{DISPLAY_DEBT}] You will need a unique name for each account, which could be a nickname, an account number, or anything else that would help you easily identify the debt.\n[{DISPLAY_DEBTOR}] Name of the institution or individual to whom you owe this debt.\n[{DISPLAY_BALANCE}] Current balance as of today's date.\n[{DISPLAY_INTEREST}] Current APR (e.g. 15.99).\n[{DISPLAY_PAYMENT}] Enter the minimum payment required by the debtor."
INSTRUCTIONS_GENERATE_PLAN = f"{MENU_GENERATE_PLAN.upper()}:\n[{DISPLAY_ACCELERATION}] You will need to provide the monthly amount you can add from your current budget to accelerate your debt repayment plan. This amount will be added to your total debt payments throughout the plan. Your plan will be generated by using the Debt Snowball method: this repayment plan focuses on early success by paying off your lowest balances before moving to higher balances. As you progress through your repayment plan, your paid off debt payment amounts are cumulatively added to your next debt. As you reach the larger balance debts, you will have more money to pay them off. NOTE: it is critical you continue to make all of you minimum payments until the plan shows you to increase your payment amount. Once completed, you will add that payment to the next debt."
INSTRUCTIONS_REMOVE_DEBT = f"{MENU_REMOVE_DEBT.upper()}:\nA summarized list of debts will show with a corresponding number for each. Please select which record you would like to remove by entering the corresponding number."
ERROR_INVALID_CHOICE = "Invalid choice"
ERROR_FEATURE_INCOMPLETE = "Feature not yet implemented"
EXIT_MESSAGE = "Good bye"

TOGGLE_STATES = [' (OFF)',' (ON)']

def main():
    running = True
    display_instructions = False
    while running == True:
        menu = []
        toggle = TOGGLE_STATES[display_instructions]
        if len(debts) < 1:
            menu.append(MENU_IMPORT_DEBT)
            menu.append(MENU_ADD_DEBT)
        else:
            menu.append(MENU_ADD_DEBT)
            menu.append(MENU_REMOVE_DEBT)
            menu.append(MENU_LIST_DEBT)
        if len(snowball_plans) < 1 and len(debts) > 1:
            menu.append(MENU_GENERATE_PLAN)
        elif len(snowball_plans) > 1:
            menu.append(MENU_GENERATE_PLAN)
            menu.append(MENU_LIST_PLANS)
            menu.append(MENU_EXPORT_PLANS)
        menu.append(MENU_INSTRUCTIONS+toggle)
        menu.append(MENU_EXIT)
        choices = menu_choices(menu)
        print(f"{MENU_HEADER}:\n")
        for key, value in choices.items():
            print(f"{key}. {value}")
        print()
        valid_choice = False
        while valid_choice == False:
            choice = input(f"{MENU_PROMPT}: ")
            try:
                index = int(choice)
                if choices[index]:
                    valid_choice = True
                else:
                    print(ERROR_INVALID_CHOICE)
            except:
                print(f"{ERROR_INVALID_CHOICE} '{choice}'")
        if choices[index] == MENU_IMPORT_DEBT:
            print(f"\n{ERROR_FEATURE_INCOMPLETE}\n")
        elif choices[index] == MENU_ADD_DEBT:
            if display_instructions:
                print(f"{INSTRUCTIONS_ADD_DEBT}\n")
            enter = True
            while enter == True:
                reenter = False
                duplicated = True # set for initial check of unique debt name
                while not reenter:
                    while duplicated:
                        debt = data_entry(prompt="Debt Name", data_type="str")
                        if debt in debts.keys(): # check for duplicate record
                            print(f"Existing record found for '{debt}'. Please reenter.")
                            duplicated = True
                        else:
                            duplicated = False
                    debtor = data_entry(prompt="Debtor", data_type="str")
                    balance = 0.0
                    while not balance > 0.0:
                        balance = data_entry(prompt="Current Balance", data_type="money")
                        if not balance > 0.0:
                            print("Please enter a balance greater than zero.")
                    interest = 0.0
                    while not interest > 0.0:
                        interest = data_entry(prompt="Interest Rate", data_type="interest")
                        if not interest > 0.0:
                            print("Please enter an interest rate greater than zero.")
                    payment = 0.0
                    while not payment > 0.0:
                        payment = data_entry(prompt=f"Minimum Payment", data_type="money")
                        if not payment > 0.0:
                            print("Please enter a payment greater than zero.")
                    print("\nPlease review:\n")
                    print(f"DEBT NAME:          {debt}")
                    print(f"   Debtor:          {debtor}")
                    print(f"   Current Balance: {format_money(balance)}")
                    print(f"   Interest Rate:   {format_percentage(interest)}")
                    print(f"   Minimum Payment: {format_money(payment)}\n")
                    reenter=data_entry(prompt="Is this correct?", data_type="boolean")
                    duplicated = not reenter
                estimated_payoff = calculate_payoff(balance, interest, payment, dt.now())
                print(f"Estimated payoff without changing current paymet: {format_month_year(estimated_payoff)}")
                debts[debt] = [debtor, balance, interest, payment, estimated_payoff]
                # payment_schedule.append([f"{payments}, {payment}, {pmt_principle}, {pmt_interest}, {balance}"])
                enter = data_entry(prompt="Enter another debt?", data_type="boolean")
        elif choices[index] == MENU_REMOVE_DEBT:
            if display_instructions:
                print(f"{INSTRUCTIONS_REMOVE_DEBT}\n")
            counter = 0
            records = []
            for debt, attribute in debts.items():
                debtor = attribute[DEBTOR_INDEX]
                balance = attribute[BALANCE_INDEX]
                interest = attribute[INTEREST_INDEX]
                payment = attribute[PAYMENT_INDEX]
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                records.append(f"{debt}, ({format_money(balance)} @ {format_percentage(interest)}) {format_money(payment)}/mo")
            records.append(f"Cancel")
            selection = menu_choices(records)
            for key, value in selection.items():
                print(f"{key}. {value}")
            print()
        elif choices[index] == MENU_LIST_DEBT:
            print(f"\nDebts found: {len(debts)}")
            for debt, attribute in debts.items():
                debtor = attribute[DEBTOR_INDEX]
                balance = attribute[BALANCE_INDEX]
                interest = attribute[INTEREST_INDEX]
                payment = attribute[PAYMENT_INDEX]
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                print(f"DEBT NAME:           {debt}")
                print(f"   Debtor:           {debtor}")
                print(f"   Current Balance:  {format_money(balance)}")
                print(f"   Interest Rate:    {format_percentage(interest)}")
                print(f"   Minimum Payment:  {format_money(payment)}")
                print(f"   Estimated Payoff: {format_month_year(estimated_payoff)}")
        elif choices[index] == MENU_GENERATE_PLAN:
            if display_instructions:
                print(f"{INSTRUCTIONS_GENERATE_PLAN}\n")
            order_payoff = []
            no_change_plans.clear()
            snowball_plans.clear()
            plan_types = ["no change", "snowball"]
            for debt, attribute in debts.items():
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                order_payoff.append([estimated_payoff, debt])
            order_payoff.sort() # sort by asc estimated payoff date
            accelerate_amount = data_entry(f"{DISPLAY_ACCELERATION}", "money")

            # Calculate current payoff date
            running_balance = 0.0
            for debt, attribute in debts.items():
                debtor = attribute[DEBTOR_INDEX]
                balance = attribute[BALANCE_INDEX]
                running_balance += balance
                interest = attribute[INTEREST_INDEX]
                payment = attribute[PAYMENT_INDEX]
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                # generate full schedule with no payment change (for later comparison)
                no_change_plans[debt] = generate_standalone_schedule(balance, interest, payment)
            # Calculate debt snowball
            month_number = 0
            total_interest = {}
            total_payments = {}
            total_balance = {}
            for _, debt in order_payoff:
                total_interest[debt] = 0.0
                total_payments[debt] = 0.0
                total_balance[debt] = debts[debt][BALANCE_INDEX]
                # snowball_plans[debt] = []
            for _, accelerated_debt in order_payoff:
                debtor = debts[accelerated_debt][DEBTOR_INDEX]
                balance = debts[accelerated_debt][BALANCE_INDEX]
                interest = debts[accelerated_debt][INTEREST_INDEX]
                payment_remainder = 0.0
                extra_available = 0.0
                while balance > 0.0: # loops until one debt is paid off
                    month_number += 1
                    monthly_total = 0.0
                    for _, current_debt in order_payoff:
                        if total_balance[current_debt] > 0.01:
                            # calculate any extra payment available
                            if accelerated_debt == current_debt:
                                extra_available = accelerate_amount
                            else:
                                extra_available = payment_remainder
                                payment_remainder = 0.0 # reset value so it can't be used again
                            pmt = debts[current_debt][PAYMENT_INDEX] + extra_available
                            pmt_interest = total_balance[current_debt] * (debts[current_debt][INTEREST_INDEX] / 12)
                            # Adjust payment if too high
                            if total_balance[current_debt] + pmt_interest < pmt:
                                # since debt is about to pay out, increase the accelerate amount for the next debt by the original debt payment
                                accelerate_amount += debts[current_debt][PAYMENT_INDEX]
                                payment_remainder = pmt - (total_balance[current_debt] + pmt_interest)
                                pmt = total_balance[current_debt] + pmt_interest
                                extra_available = 0.0 # since all extra has been placed in payment remainder, empty this
                            if extra_available > 0.0:
                                extra = f" [{format_money(pmt-extra_available)} +{format_money(extra_available)}]"
                            else:
                                extra = ""
                            pmt_principle = pmt - pmt_interest
                            total_balance[current_debt] -= pmt_principle
                            if accelerated_debt == current_debt:
                                balance = total_balance[current_debt] # update balance keeping the main loop going
                            # keep running totals for current debt
                            total_interest[current_debt] += pmt_interest
                            total_payments[current_debt] += pmt
                            monthly_total += pmt
                            if pmt > 0.0: # if any payment was made to current debt, record it in the plan
                                try:
                                    snowball_plans[''].append([current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]])
                                    snowball_plans[current_debt].append([current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]])
                                except KeyError:
                                    snowball_plans[''] = [[current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]]]
                                    snowball_plans[current_debt] = [[current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]]]
                        else:
                            balance = 0.0
                    if monthly_total > 0.0:
                        print(f"[Total Payments {format_month_year(add_months(dt.now(), month_number))}] {format_money(monthly_total)}")
            for debt, column in snowball_plans.items():
                for name, month_number, pmt, accelerate_amount, pmt_principle, pmt_interest, total_balance, total_interest in column:
                    print(f"{format_month_year(add_months(dt.now(), month_number))} {name} {format_money(pmt)} {format_money(accelerate_amount)} ({format_money(pmt_principle)} {format_money(pmt_interest)}) [{format_money(total_balance)}] {format_money(total_interest)}")
        elif choices[index] == MENU_LIST_PLANS:
            print(f"\n{ERROR_FEATURE_INCOMPLETE}\n")
        elif choices[index] == MENU_EXPORT_PLANS:
            print(f"\n{ERROR_FEATURE_INCOMPLETE}\n")
        elif choices[index] == MENU_INSTRUCTIONS+toggle:
            # toggle value for display instructions
            display_instructions = not display_instructions
        elif choices[index] == MENU_EXIT:
            running = False
            print(f"\n{EXIT_MESSAGE}!\n")

def data_entry(prompt, data_type):
    """Basic data entry prompt with retry until
    correct data type is entered
    Parameters:
        prompt: string to prompt user for input.
            If the prompt ends in a '?', a space
            will be placed after the prompt before
            allowing input. Otherwise, a ':' will
            be inserted before the space.
        data_type: one of the following values is
            accepted:
                "str" - string
                "money" - real, currency format
                "interest" - real, interest format
                "boolean" - boolean, y or n prompt
    Returns:
        User-entered, data-type-forced type
    """
    if prompt[len(prompt) - 1] == "?":
        end_character = ""
    else:
        end_character = ":"
    if data_type == "money":
        entry_prefix = "$"
    else:
        entry_prefix = ""
    valid = False
    while not valid:
        entry = input(f"{prompt}{end_character} {entry_prefix}")
        try:
            match data_type:
                case "str":
                    data = entry
                    valid = True
                case "money":
                    data = float(entry)
                    valid = True
                case "interest":
                    data = float(entry)/100
                    valid = True
                case "boolean" | "Y or N":
                    data_type = "Y or N"
                    if entry.lower() == "y":
                        data = True
                        valid = True
                    elif entry.lower() == "n":
                        data = False
                        valid = True
                    else:
                        valid = False
                        raise TypeError
        except:
            print(f"Invalid data. Expected '{data_type}'")
            entry = ""
            valid = False
    return data

def generate_standalone_schedule(principle, interest, payment, interest_to_date=0.0, start_at_payment=0):
    payment_schedule = []
    balance = principle
    total_interest = interest_to_date
    payments = start_at_payment # defaults to zero
    while balance > 0.0:
        payments += 1
        pmt_interest = balance * interest / 12
        pmt_principle = payment - pmt_interest
        total_interest += pmt_interest
        if balance + pmt_interest < payment:
            payment = balance
            pmt_principle = balance - pmt_interest
            balance = 0.0
        else:
            balance -= pmt_principle
        payment_schedule.append([payments, payment, pmt_principle, pmt_interest, balance])
    return payment_schedule

def calculate_payoff(balance, interest, payment, start_date):
    months = period.calculate_amortization_period(balance, interest, payment)
    payoff = add_months(start_date, months)
    return payoff

def menu_choices(options):
    dictionary = {}
    counter = 0
    for item in options:
        counter += 1
        dictionary[counter] = item
    return dictionary

def add_months(current_date, months_to_add):
    new_date = dt(current_date.year + (current_date.month + months_to_add - 1) // 12,
                        (current_date.month + months_to_add - 1) % 12 + 1,
                        current_date.day, current_date.hour, current_date.minute, current_date.second)
    return new_date

def format_month_year(timestamp):
    return f"{timestamp:%b %Y}"

def format_money(money):
    """Display float as money, with negative before
    the dollar sign.
    Parameter:
        money: float to be converted to money format
    Return:
        string formatted with $d,ddd.cc, negative values
        precede the $ sign
    """
    if money >= 0:
        return f"${money:,.2f}"
    else:
        return f"-${abs(money):,.2f}"

def format_percentage(rate, decimals=2):
    """Display float as percentage
    Parameter:
        rate: float to be converted to percentage
        decimals: number of decimals to return,
            defaults to 2. Pass -1 to switch to general
            number format (% is still appended).
    Return:
        string formatted with rate * 100 with % appended
    """
    if decimals == -1:
        return f"{rate * 100:g}%"
    else:
        return f"{rate:.{decimals}%}"

if __name__ == "__main__":
    main()