"""
Program:    Debt Freedom Planner
Author:     Traek Malan
Updated:    2024-07-27
GitHub:     https://github.com/traek/debt-freedom-planner
"""

from datetime import datetime as dt
import amortization.period as period # used for non-accelerated estimates only

debts = {}
no_change_plans = {}
snowball_plans = {}

debts = {
    'VentureOne VISA':  ['CapitalOne', 4000, 0.0899,  85.00, dt(2029, 5, 24)],
    'Best Buy MC':      ['Citibank',   6500, 0.1599, 165.00, dt(2029, 3, 24)],
    'Costco VISA':      ['Citibank',   1500, 0.1899,  39.00, dt(2029, 7, 24)],
    'Timmy\'s Bill':    ['Dr. Smith',  1000, 0.1,     25.00, dt(2028, 8, 24)],
    'Corolla Loan':     ['Chase',      8500, 0.0525, 200.00, dt(2028, 6, 24)]
}

# Columns in debts dictionary
DEBTOR_INDEX = 0
BALANCE_INDEX = 1
INTEREST_INDEX = 2
PAYMENT_INDEX = 3
ESTIMATED_PAYOFF_INDEX = 4

# Columns in _plans dictionaries
PLAN_DEBT_INDEX = 0
PLAN_MONTH_INDEX = 1
PLAN_PMT_INDEX = 2
PLAN_EXTRA_INDEX = 3
PLAN_PMT_PRINCIPLE_INDEX = 4
PLAN_PMT_INTEREST_INDEX = 5
PLAN_RUNNING_BALANCE_INDEX = 6
PLAN_INTEREST_TO_DATE_INDEX = 7

# place to implement translation(s)
MENU_IMPORT_DEBT = "Import debts from CSV template"
MENU_ADD_DEBT = "Add Debt"
MENU_REMOVE_DEBT = "Remove Debts"
MENU_LIST_DEBT = "List Debts"
MENU_GENERATE_PLAN = "Generate Repayment Plan"
MENU_LIST_PLANS = "View Repayment Plans"
MENU_EXPORT_PLANS = "Export repayment plans to CSV"
MENU_INSTRUCTIONS = "Toggle Instructions"
MENU_EXIT = "Exit"
MENU_HEADER = "Please select one of the following options"
MENU_PROMPT = "Enter selection"
DISPLAY_DEBT = "Debt Name"
DISPLAY_DEBTOR = "Debtor"
DISPLAY_BALANCE = "Current Balance"
DISPLAY_INTEREST = "Interest Rate"
DISPLAY_PAYMENT = "Minimum Payment"
DISPLAY_ACCELERATION = "Monthly amount to devote to debt acceleration"
DISPLAY_DEBT_SELECTION = "Debt Plan Type"
INSTRUCTIONS_ADD_DEBT = f"{MENU_ADD_DEBT.upper()}:\n[{DISPLAY_DEBT}] You will need a unique name for each account, which could be a nickname, an account number, or anything else that would help you easily identify the debt.\n[{DISPLAY_DEBTOR}] Name of the institution or individual to whom you owe this debt.\n[{DISPLAY_BALANCE}] Current balance as of today's date.\n[{DISPLAY_INTEREST}] Annual percentage rate (APR) or the annually adjusted interest rate applied to the principle each month (e.g. 15.99%). Please enter a number up to 4 digits. Do not enter % as part of your input.\n[{DISPLAY_PAYMENT}] Enter the minimum payment (principle + interest) required by the debtor. Typically this is the interest accrued for the month (balance * interest rate / 12) plus 1% to 3% of the current balance for most types of revolving debt. Again, PLEASE INPUT only the amount of your minimum payment that is PRINCIPLE + INTEREST. Escrows fees for mortgages include things like home owner's insurance and property taxes while other fees on revolving debt may be included for different insurance products, meant to make your minimum payment in the event of a loss of income. These fees should not be included and will interfere with the accuracy of your debt freedom plan."
INSTRUCTIONS_GENERATE_PLAN = f"{MENU_GENERATE_PLAN.upper()}:\n[{DISPLAY_ACCELERATION}] You will need to provide the monthly amount you can add from your current budget to accelerate your debt repayment plan. This amount will be added to your total debt payments throughout the plan. Your plan will be generated by using the Debt Snowball method: this repayment plan focuses on early success by paying off your lowest balances before moving to higher balances. As you progress through your repayment plan, your paid off debt payment amounts are cumulatively added to your next debt. As you reach the larger balance debts, you will have more money to pay them off. NOTE: it is critical you continue to make all of you minimum payments until the plan shows you to increase your payment amount. Once completed, you will add that payment to the next debt."
INSTRUCTIONS_REMOVE_DEBT = f"{MENU_REMOVE_DEBT.upper()}:\nA summarized list of debts will show with a corresponding number for each. Please select which record you would like to remove by entering the corresponding number."
ERROR_INVALID_CHOICE = "Invalid choice"
ERROR_FEATURE_INCOMPLETE = "Feature not yet implemented"
EXIT_MESSAGE = "Good bye"

TOGGLE_STATES = [' (OFF)',' (ON)']
LEGAL_MAXIMUM_APR = 0.36
LEGAL_MINIMUM_PMT_BALANCE_PERCENTAGE = 0.01

def main():
    running = True
    display_instructions = False
    while running == True:
        menu = []
        toggle = TOGGLE_STATES[display_instructions]
        if len(debts) < 1:
            menu.append(MENU_IMPORT_DEBT)
            menu.append(MENU_ADD_DEBT)
        else:
            menu.append(MENU_ADD_DEBT)
            # menu.append(MENU_REMOVE_DEBT)
            menu.append(MENU_LIST_DEBT)
        if len(snowball_plans) < 1 and len(debts) > 1:
            menu.append(MENU_GENERATE_PLAN)
        elif len(snowball_plans) > 1:
            menu.append(MENU_GENERATE_PLAN)
            menu.append(MENU_LIST_PLANS)
            # menu.append(MENU_EXPORT_PLANS)
        menu.append(MENU_INSTRUCTIONS+toggle)
        menu.append(MENU_EXIT)
        choices = menu_choices(menu)
        print(f"{MENU_HEADER}:\n")
        for key, value in choices.items():
            print(f"{key}. {value}")
        print()
        valid_choice = False
        while valid_choice == False:
            choice = input(f"{MENU_PROMPT}: ")
            try:
                index = int(choice)
                if choices[index]:
                    valid_choice = True
                else:
                    print(ERROR_INVALID_CHOICE)
            except:
                print(f"{ERROR_INVALID_CHOICE} '{choice}'")
        if choices[index] == MENU_IMPORT_DEBT:
            print(f"\n{ERROR_FEATURE_INCOMPLETE}\n")
        elif choices[index] == MENU_ADD_DEBT:
            if display_instructions:
                print(f"{INSTRUCTIONS_ADD_DEBT}\n")
            enter = True
            while enter == True:
                reenter = False
                duplicated = True # set for initial check of unique debt name
                while not reenter:
                    while duplicated:
                        debt = data_entry(prompt="Debt Name", data_type="str")
                        if debt in debts.keys(): # check for duplicate record
                            print(f"Existing record found for '{debt}'. Please reenter.")
                            duplicated = True
                        else:
                            duplicated = False
                    debtor = data_entry(prompt="Debtor", data_type="str")
                    balance = 0.0
                    while not balance > 0.0:
                        balance = data_entry(prompt="Current Balance", data_type="money")
                        if not balance > 0.0:
                            print("Please enter a balance greater than zero.")
                    interest = 0.0
                    # while not (LEGAL_MAXIMUM_APR <= interest > 0.0):
                    while interest > LEGAL_MAXIMUM_APR or interest == 0.0:
                        interest = data_entry(prompt="Interest Rate", data_type="interest")
                        if not interest > 0.0:
                            print("Please enter an interest rate greater than zero.")
                        elif interest >= LEGAL_MAXIMUM_APR:
                            print(f"The legal maximum APR is {format_percentage(LEGAL_MAXIMUM_APR)}. Please enter a lower number.")
                    payment = 0.0
                    current_interest_pmt = calculate_interest_pmt(balance, interest)
                    minimum_balance_pmt = balance * LEGAL_MINIMUM_PMT_BALANCE_PERCENTAGE
                    if minimum_balance_pmt > 0.0:
                        minimum_balance_amount_message = f" plus {format_percentage(LEGAL_MINIMUM_PMT_BALANCE_PERCENTAGE)} of the balance ({format_money(minimum_balance_pmt)})"
                    legal_minimum = current_interest_pmt + minimum_balance_pmt
                    while not payment >= legal_minimum:
                        payment = data_entry(prompt=f"Minimum Payment", data_type="money")
                        if not payment >= legal_minimum:
                            print(f"Minimum payment must cover at least monthly interest ({format_money(current_interest_pmt)}){minimum_balance_amount_message}. Enter a payment of at least {format_money(legal_minimum)}.")
                    print("\nPlease review:\n")
                    display_debt_entry(debt, debtor, balance, interest, payment)
                    reenter=data_entry(prompt="Is this correct?", data_type="boolean")
                    duplicated = not reenter
                estimated_payoff = calculate_payoff(balance, interest, payment, dt.now())
                print(f"Estimated payoff without changing current payment: {format_month_year(estimated_payoff)}")
                debts[debt] = [debtor, balance, interest, payment, estimated_payoff]
                # payment_schedule.append([f"{payments}, {payment}, {pmt_principle}, {pmt_interest}, {balance}"])
                enter = data_entry(prompt="Enter another debt?", data_type="boolean")
        elif choices[index] == MENU_REMOVE_DEBT:
            if display_instructions:
                print(f"{INSTRUCTIONS_REMOVE_DEBT}\n")
            counter = 0
            records = []
            for debt, attribute in debts.items():
                debtor = attribute[DEBTOR_INDEX]
                balance = attribute[BALANCE_INDEX]
                interest = attribute[INTEREST_INDEX]
                payment = attribute[PAYMENT_INDEX]
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                records.append(f"{debt}, ({format_money(balance)} @ {format_percentage(interest)}) {format_money(payment)}/mo")
            records.append(f"Cancel")
            selection = menu_choices(records)
            for key, value in selection.items():
                print(f"{key}. {value}")
            print()
        elif choices[index] == MENU_LIST_DEBT:
            print(f"\nDebts found: {len(debts)}")
            for debt, attribute in debts.items():
                debtor = attribute[DEBTOR_INDEX]
                balance = attribute[BALANCE_INDEX]
                interest = attribute[INTEREST_INDEX]
                payment = attribute[PAYMENT_INDEX]
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                display_debt_entry(debt, debtor, balance, interest, payment, estimated_payoff)
        elif choices[index] == MENU_GENERATE_PLAN:
            if display_instructions:
                print(f"{INSTRUCTIONS_GENERATE_PLAN}\n")
            order_payoff = []
            no_change_plans.clear()
            snowball_plans.clear()
            total_monthly_payments = 0.0
            for debt, attribute in debts.items():
                payment = attribute[PAYMENT_INDEX]
                total_monthly_payments += payment                
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                order_payoff.append([estimated_payoff, debt])
            order_payoff.sort() # sort by asc estimated payoff date
            print(f"Current total monthly debt payments: {format_money(total_monthly_payments)}")
            accelerate_amount = data_entry(f"{DISPLAY_ACCELERATION}", "money")
            # Calculate current payoff date
            total_monthly_payments = 0.0
            for debt, attribute in debts.items():
                debtor = attribute[DEBTOR_INDEX]
                balance = attribute[BALANCE_INDEX]
                interest = attribute[INTEREST_INDEX]
                payment = attribute[PAYMENT_INDEX]
                estimated_payoff = attribute[ESTIMATED_PAYOFF_INDEX]
                # generate full schedule with no payment change (for later comparison)
                no_change_plans[debt] = generate_standalone_schedule(balance, interest, payment)
            # Calculate debt snowball
            month_number = 0
            total_interest = {}
            total_payments = {}
            total_balance = {}
            for _, debt in order_payoff:
                total_interest[debt] = 0.0
                total_payments[debt] = 0.0
                total_balance[debt] = debts[debt][BALANCE_INDEX]
            for _, accelerated_debt in order_payoff:
                debtor = debts[accelerated_debt][DEBTOR_INDEX]
                balance = debts[accelerated_debt][BALANCE_INDEX]
                interest = debts[accelerated_debt][INTEREST_INDEX]
                payment_remainder = 0.0
                extra_available = 0.0
                while balance > 0.0: # loops until one debt is paid off
                    month_number += 1
                    monthly_total = 0.0
                    for _, current_debt in order_payoff:
                        if total_balance[current_debt] > 0.01:
                            # calculate any extra payment available
                            if accelerated_debt == current_debt:
                                extra_available = accelerate_amount
                            else:
                                extra_available = payment_remainder
                                payment_remainder = 0.0 # reset value so it can't be used again
                            pmt = debts[current_debt][PAYMENT_INDEX] + extra_available
                            pmt_interest = calculate_interest_pmt(total_balance[current_debt], debts[current_debt][INTEREST_INDEX])
                            # Adjust payment if too high
                            if total_balance[current_debt] + pmt_interest < pmt:
                                # since debt is about to pay out, increase the accelerate amount for the next debt by the original debt payment
                                accelerate_amount += debts[current_debt][PAYMENT_INDEX]
                                payment_remainder = pmt - (total_balance[current_debt] + pmt_interest)
                                pmt = total_balance[current_debt] + pmt_interest
                                extra_available = 0.0 # since all extra has been placed in payment remainder, empty this
                            pmt_principle = pmt - pmt_interest
                            total_balance[current_debt] -= pmt_principle
                            if accelerated_debt == current_debt:
                                balance = total_balance[current_debt] # update balance keeping the main loop going
                            # keep running totals for current debt
                            total_interest[current_debt] += pmt_interest
                            total_payments[current_debt] += pmt
                            monthly_total += pmt
                            if pmt > 0.0: # if any payment was made to current debt, record it in the plan
                                try:
                                    snowball_plans[''].append([current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]])
                                    snowball_plans[current_debt].append([current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]])
                                except KeyError:
                                    snowball_plans[''] = [[current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]]]
                                    snowball_plans[current_debt] = [[current_debt, month_number, pmt, extra_available, pmt_principle, pmt_interest, total_balance[current_debt], total_interest[current_debt]]]
                        else:
                            balance = 0.0
                    print(f"Generating payments for {format_month_year(add_months(dt.now(), month_number))}: {format_money(monthly_total)} total debt payments")
            print(f"\nDebt freedom plan completes on {format_month_year(add_months(dt.now(), month_number))} ({month_number} months from now).")
            print(f"Please select '{MENU_LIST_PLANS}' to view details.\n")                    
        elif choices[index] == MENU_LIST_PLANS:
            for debt, column in snowball_plans.items():
                #if debt != "":
                    print(f"\n{debt.upper()} Payoff Plan:")
                    for name, month_number, pmt, accelerate_amount, pmt_principle, pmt_interest, total_balance, total_interest in column:
                        if accelerate_amount == 0.0:
                            accelerate_amount = ""
                        else:
                            accelerate_amount = f"extra: {format_money(accelerate_amount)} "
                        print(f"{format_month_year(add_months(dt.now(), month_number))} {name} pmt: {format_money(pmt)} ({accelerate_amount}principle: {format_money(pmt_principle)} interest: {format_money(pmt_interest)}) (interest-to-date: {format_money(total_interest)}) [BALANCE: {format_money(total_balance)}]")
            print()
        elif choices[index] == MENU_EXPORT_PLANS:
            print(f"\n{ERROR_FEATURE_INCOMPLETE}\n")
        elif choices[index] == MENU_INSTRUCTIONS+toggle:
            # toggle value for display instructions
            display_instructions = not display_instructions
        elif choices[index] == MENU_EXIT:
            running = False
            print(f"\n{EXIT_MESSAGE}!\n")

def data_entry(prompt, data_type):
    if prompt[len(prompt) - 1] == "?":
        end_character = ""
    else:
        end_character = ":"
    if data_type == "money":
        entry_prefix = "$"
    else:
        entry_prefix = ""
    valid = False
    while not valid:
        entry = input(f"{prompt}{end_character} {entry_prefix}")
        try:
            match data_type:
                case "str":
                    data = entry
                    valid = True
                case "money":
                    data = float(entry)
                    valid = True
                case "interest":
                    data = float(entry)/100
                    valid = True
                case "boolean" | "Y or N":
                    data_type = "Y or N"
                    if entry.lower() == "y":
                        data = True
                        valid = True
                    elif entry.lower() == "n":
                        data = False
                        valid = True
                    else:
                        valid = False
                        raise TypeError
        except:
            print(f"Invalid data. Expected '{data_type}'")
            entry = ""
            valid = False
    return data

def display_debt_entry(debt, debtor, balance, interest, payment, estimated_payoff=dt.now()):
    planned_payoff = get_debt_planned_payoff(debt)
    print(f"DEBT NAME:          {debt}")
    print(f"   Debtor:          {debtor}")
    print(f"   Current Balance: {format_money(balance)}")
    print(f"   Interest Rate:   {format_percentage(interest)}")
    print(f"   Minimum Payment: {format_money(payment)}")
    if format_month_year(estimated_payoff) != format_month_year(dt.now()):
        print(f"   Current Paid By: {format_month_year(estimated_payoff)}")
    if planned_payoff > 0:
        print(f"   Planned Payoff:  {format_month_year(add_months(dt.now(), planned_payoff))}")    
    print()
    return

def generate_standalone_schedule(principle, interest, payment, interest_to_date=0.0, start_at_payment=0):
    payment_schedule = []
    balance = principle
    total_interest = interest_to_date
    payments = start_at_payment # defaults to zero
    while balance > 0.0:
        payments += 1
        pmt_interest = balance * interest / 12
        pmt_principle = payment - pmt_interest
        total_interest += pmt_interest
        if balance + pmt_interest < payment:
            payment = balance
            pmt_principle = balance - pmt_interest
            balance = 0.0
        else:
            balance -= pmt_principle
        payment_schedule.append([payments, payment, pmt_principle, pmt_interest, balance])
    return payment_schedule

def calculate_payoff(balance, interest, payment, start_date):
    months = period.calculate_amortization_period(balance, interest, payment)
    payoff = add_months(start_date, months)
    return payoff

def calculate_interest_pmt(current_balance, interest_rate):
    return current_balance * (interest_rate / 12)

def get_debt_planned_payoff(debt):
    try:
        planned_payoff = snowball_plans[debt][-1][PLAN_MONTH_INDEX]
    except:
        planned_payoff = 0
    return planned_payoff

def menu_choices(options):
    dictionary = {}
    counter = 0
    for item in options:
        counter += 1
        dictionary[counter] = item
    return dictionary

def add_months(current_date, months_to_add):
    new_date = dt(
        current_date.year + (current_date.month + months_to_add - 1) // 12,
        (current_date.month + months_to_add - 1) % 12 + 1, current_date.day)
    return new_date

def format_month_year(timestamp):
    return f"{timestamp:%b %Y}"

def format_money(money):
    if money >= 0:
        return f"${money:,.2f}"
    else:
        return f"-${abs(money):,.2f}"

def format_percentage(rate, decimals=2):
    if decimals == -1:
        return f"{rate * 100:g}%"
    else:
        return f"{rate:.{decimals}%}"

if __name__ == "__main__":
    main()